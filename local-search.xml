<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux-4</title>
    <link href="/2022/03/02/Linux-4/"/>
    <url>/2022/03/02/Linux-4/</url>
    
    <content type="html"><![CDATA[<h1 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h1><p><strong>介绍</strong></p><p>shell是命令行解释器，为用户提供了一个向Linux内核发送请求来运行程序的界面系统和程序</p><p><strong>脚本格式要求</strong></p><p>以<code>#!/bin/bash</code>开头</p><p>脚本需要有可执行权限</p><p><strong>编写第一个shell脚本</strong></p><figure class="highlight d"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs d">创建一个shell脚本，输出hello world<br>vim hello.sh<br><span class="hljs-meta">#!/bin/bash</span><br>echo <span class="hljs-string">&quot;hello world&quot;</span><br></code></pre></td></tr></table></figure><p><strong>脚本常用的执行方式</strong></p><ol><li><p>输入脚本的绝对路径或相对路径</p><p>首先要赋予hello.sh脚本的+x权限，再执行脚本</p></li><li><p>sh+脚本</p><p>可以不用赋予脚本+x权限，直接执行即可</p><p>例如：sh hello.sh（也可使用绝对路径）</p></li></ol><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> /root/shcode<br><span class="hljs-built_in">cd</span> /root/shcode/<br><span class="hljs-built_in">ls</span><br>vim hello.sh<br>【文件中】<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello,world~&quot;</span><br>【退出文件】<br></code></pre></td></tr></table></figure><p><img src="D:\typora\AllImages\20220228185028.png" alt="image-20220227160802938"></p><p><img src="D:\typora\AllImages\20220228185030.png" alt="image-20220226151427317"></p></blockquote><h2 id="shell的变量"><a href="#shell的变量" class="headerlink" title="shell的变量"></a>shell的变量</h2><p><strong>介绍</strong></p><p>shell变量分为系统变量和用户自定义变量</p><p>系统变量：$HOME，$PWD等</p><p>显示当前shell中所有变量：<code>set</code></p><p><strong>shell变量的定义</strong></p><p>定义变量 ： <code>变量=值</code></p><p>撤销变量 ： <code>unset 变量</code></p><p>声明静态变量 ：<code>readonly 变量</code>（注意：不能unset）</p><p><strong>应用实例</strong></p><blockquote><p>创建文件</p><p><code>vim var.sh</code></p><p>执行脚本</p><p><code>./var.sh</code></p><p><img src="D:\typora\AllImages\20220228185033.png" alt="image-20220226151637198"></p></blockquote><p><strong>shell变量的定义规则</strong></p><p>变量名称可以由字母、数字和下划线组成，但是不能以数字开头</p><p>等号两侧不能有空格</p><p>变量名称一般习惯为大写</p><p><strong>将命令的返回值赋给变量</strong></p><p>A&#x3D;`date` 反引号，运行里面的命令，把结果返回给变量Ａ</p><p>A&#x3D;$(date) 等价上面的写法 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">C=`<span class="hljs-built_in">date</span>`<br>D=$(<span class="hljs-built_in">date</span>)<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;C=<span class="hljs-variable">$C</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;D=<span class="hljs-variable">$D</span>&quot;</span><br></code></pre></td></tr></table></figure><h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p><strong>基本语法</strong></p><p>将shell变量输出为环境变量（全局变量）</p><p>让修改后的配置信息立刻生效</p><p>查询环境变量的值</p><p><strong>应用案例</strong></p><p>在&#x2F;etc&#x2F;profile文件中定义TOMCAT_HOME环境变量</p><p>查看环境变量TOMCAT_HOME的值</p><p>在另一个shell程序中使用TOMCAT_HOME</p><blockquote><p>注意：在输出TOMCAT_HOME之前，需要让其生效</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/opt/</span><br>vim <span class="hljs-regexp">/etc/</span>profile<br></code></pre></td></tr></table></figure><p><img src="D:\typora\AllImages\20220228185039.png" alt="image-20220226212829099"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$TOMCAT_HOME</span><br><span class="hljs-built_in">source</span> /etc/profile<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$TOMCAT_HOME</span><br></code></pre></td></tr></table></figure><p><img src="D:\typora\AllImages\20220228185043.png" alt="image-20220226212908467"></p></blockquote><p><strong>shell的多行注释</strong>：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">:&lt;&lt;!<br>……<br>!<br></code></pre></td></tr></table></figure><h3 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h3><p><strong>介绍</strong></p><p>当我们执行shell脚本时，如果希望获取到命令行的参数信息，就要使用位置参数变量</p><p>例如：<code>./myshell.sh 100 200</code>， 就是一个执行shell的命令行，可以在myshell脚本中获取到参数信息</p><p><strong>基本语法</strong></p><p><img src="D:\typora\AllImages\20220228185047.png" alt="image-20220227162629961"></p><p><strong>位置参数变量</strong></p><p>编写一个shell脚本position.sh，在脚本中获取到命令行的各个参数信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim position.sh<br>【文件中】<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;0=<span class="hljs-variable">$0</span> 1=<span class="hljs-variable">$1</span> 2=<span class="hljs-variable">$2</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;所有的参数=$*&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;参数的个数=<span class="hljs-variable">$#</span>&quot;</span><br>【退出文件】<br><span class="hljs-built_in">chmod</span> u+x position.sh<br>./position.sh 100 200<br></code></pre></td></tr></table></figure><h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><p><strong>介绍</strong></p><p>预定义变量就是shell设计者定义好的变量，可以直接在shell脚本中调用</p><p><strong>基本语法</strong></p><p><code>$$</code>    当前进程的进程号（PID）</p><p><code>$!</code>    后台运行的最后一个进程的进程号（PID）</p><p><code>$?</code>    最后一次执行的命令的返回状态，如果这个变量的值为0，则上一个命令正确执行；如果非0，则执行不正确。</p><p><strong>应用实例</strong></p><p>在shell脚本中简单实用预定义变量</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">vim</span> perVar.<span class="hljs-keyword">sh</span><br>【文件中】<br>#!/bin/bash<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;当前执行的进程id=$$&quot;</span><br># 以后台的方式运行一个脚本，并获取他的进程号<br>/root/shcode/position.<span class="hljs-keyword">sh</span> &amp;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;最后一个后台方式运行的进程id=$!&quot;</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;执行的结果是$?&quot;</span><br>【退出文件】<br>chmod <span class="hljs-keyword">u</span>+<span class="hljs-keyword">x</span> perVar.<span class="hljs-keyword">sh</span><br>./ preVar.<span class="hljs-keyword">sh</span><br></code></pre></td></tr></table></figure><h2 id="shell运算符"><a href="#shell运算符" class="headerlink" title="shell运算符"></a>shell运算符</h2><p><strong>基本语法</strong></p><ol><li><p><code>$((运算式))</code>   或   <code>$[运算式]</code>   或者  <code>expr m + n</code> </p></li><li><p>expr运算符之间<u>要有空格</u>，如果希望将expr的值赋给某个变量，使用&#96;&#96;</p><p>如果没有空格，会被当成一个整体</p></li><li><p><code>expr m - n</code> </p></li><li><p><u>\*</u>  &#x2F;  % 乘、除、取余</p></li></ol><p><strong>应用实例</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">计算（2<span class="hljs-string">+3</span>）×4的值<br>请求出命令行的两个参数的和<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim oper.sh<br>【文件中】<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># 案例一</span><br>RES1=$(((<span class="hljs-number">2</span>+<span class="hljs-number">3</span>)*<span class="hljs-number">4</span>))<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;res1=<span class="hljs-variable">$RES1</span>&quot;</span><br><br>RES2=$[(2+3)*4]<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;res2=<span class="hljs-variable">$RES2</span>&quot;</span><br><br>TEMP=`<span class="hljs-built_in">expr</span> 2 + 3`<br>RES3=`<span class="hljs-built_in">expr</span> <span class="hljs-variable">$TEMP</span> \* 4`<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;res3=<span class="hljs-variable">$RES3</span>&quot;</span><br><br><span class="hljs-comment"># 案例二</span><br>SUM=[<span class="hljs-variable">$1</span>+<span class="hljs-variable">$2</span>]<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;sum=<span class="hljs-variable">$SUM</span>&quot;</span><br><br>【退出文件】<br><span class="hljs-built_in">chmod</span> u+x oper.sh<br>./oper.sh<br></code></pre></td></tr></table></figure><h2 id="循环和判断"><a href="#循环和判断" class="headerlink" title="循环和判断"></a>循环和判断</h2><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p><strong>基本语法</strong></p><p><code>[ condition ]</code> </p><p>注意condition前后都有空格</p><p>非空返回true，可使用$?验证（0为true，大于1为false）</p><p><strong>常见判断</strong></p><ol><li><p>字符串比较 <code>=</code> </p></li><li><p>两个整数的比较</p><table><thead><tr><th>-lt</th><th>小于</th></tr></thead><tbody><tr><td>-le</td><td>小于等于</td></tr><tr><td>-eq</td><td>等于</td></tr><tr><td>-gt</td><td>大于</td></tr><tr><td>-ge</td><td>大于等于</td></tr><tr><td>-ne</td><td>不等于</td></tr></tbody></table></li><li><p>按照文件的权限进行判断</p><table><thead><tr><th>-r</th><th>有读的权限</th></tr></thead><tbody><tr><td>-w</td><td>有写的权限</td></tr><tr><td>-x</td><td>有执行的权限</td></tr></tbody></table></li><li><p>按照文件类型进行判断</p><table><thead><tr><th>-f</th><th>文件存在并且是一个常规的文件</th></tr></thead><tbody><tr><td>-e</td><td>文件存在</td></tr><tr><td>-d</td><td>文件存在并且是一个目录</td></tr></tbody></table></li></ol><p><strong>应用实例</strong></p><blockquote><p><code>vim ifdemo.sh</code></p><p>【文件中】</p><p><img src="D:\typora\AllImages\20220228185053.png" alt="image-20220226214023550"></p><p>【退出文件】</p><p><code>chmod u+x ifdemo.sh</code></p><p><code>./ifdemo.sh</code></p></blockquote><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p><strong>应用案例</strong></p><p>编写一个shell程序，如果输入的参数大于等于60则输出“及格了”，否则输出“不及格”</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim ifCase.sh<br>【文件中】<br><span class="hljs-comment">#！/bin/bash</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$1</span> -ge 60 ]<br><span class="hljs-keyword">then</span> <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;及格了&quot;</span><br><span class="hljs-keyword">elif</span> [ <span class="hljs-variable">$1</span> -lt 60 ]<br><span class="hljs-keyword">then</span> <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;不及格&quot;</span><br><span class="hljs-keyword">fi</span><br>【退出文件】<br><span class="hljs-built_in">chmod</span> u+x ifCase.sh<br>./ifCase.sh 70<br></code></pre></td></tr></table></figure><h4 id="case"><a href="#case" class="headerlink" title="case"></a>case</h4><p><strong>应用案例</strong></p><p>当命令行参数是1就输出“周一”，如果是2就输出“周二”，其他情况输出“other”</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim testCase.sh<br>【文件中】<br><span class="hljs-comment">#！/bin/bash</span><br><span class="hljs-keyword">case</span> <span class="hljs-variable">$1</span> <span class="hljs-keyword">in</span><br><span class="hljs-string">&quot;1&quot;</span>)<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;周一&quot;</span><br>;;<br><span class="hljs-string">&quot;2&quot;</span>)<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;周二&quot;</span><br>;;<br>*)<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;其他&quot;</span><br>;;<br><span class="hljs-keyword">esac</span><br>【退出文件】<br><span class="hljs-built_in">chmod</span> u+x testCase.sh<br>./testCase.sh 2<br></code></pre></td></tr></table></figure><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p><strong>案例一</strong>：</p><p>打印命令行输入的参数</p><p>可以看出$*和$@的区别</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim testFor1.sh<br>【文件中】<br><span class="hljs-comment">#！/bin/bash</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;$*&quot;</span><br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;num is <span class="hljs-variable">$1</span>&quot;</span><br><span class="hljs-keyword">done</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;=================&quot;</span><br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br><span class="hljs-keyword">do</span> <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;num is <span class="hljs-variable">$j</span>&quot;</span><br><span class="hljs-keyword">done</span><br>【退出文件】<br><span class="hljs-built_in">chmod</span> u+x testFor1.sh<br>./testFor1.sh 100 200 300<br></code></pre></td></tr></table></figure><p><strong>案例二</strong>：</p><p>从1加到100的输出显示</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs routeros">vim testFor2.sh<br>【文件中】<br><span class="hljs-comment">#！/bin/bash</span><br><span class="hljs-attribute">SUM</span>=0<br><span class="hljs-keyword">for</span>(( <span class="hljs-attribute">i</span>=1;i&lt;=100;i++))<br><span class="hljs-keyword">do</span><br><span class="hljs-attribute">SUM</span>=$[<span class="hljs-variable">$SUM</span>+<span class="hljs-variable">$i</span>]<br>done<br>echo <span class="hljs-string">&quot;总和SUM=<span class="hljs-variable">$SUM</span>&quot;</span><br><br>echo <span class="hljs-string">&quot;=================&quot;</span><br><span class="hljs-attribute">SUM</span>=0<br><span class="hljs-keyword">for</span>(( <span class="hljs-attribute">i</span>=1;i&lt;=$1;i++))<br><span class="hljs-keyword">do</span><br><span class="hljs-attribute">SUM</span>=$[<span class="hljs-variable">$SUM</span>+<span class="hljs-variable">$i</span>]<br>done<br>echo <span class="hljs-string">&quot;自定义总和SUM=<span class="hljs-variable">$SUM</span>&quot;</span><br>【退出文件】<br>chmod u+x testFor2.sh<br>./testFor2.sh<br></code></pre></td></tr></table></figure><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p>案例一：</p><p>从命令行输入一个数n，统计从1+…+n的值是多少</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs routeros">vim testWhile.sh<br>【文件中】<br><span class="hljs-comment">#！/bin/bash</span><br><span class="hljs-attribute">SUM</span>=0<br><span class="hljs-attribute">i</span>=0<br><span class="hljs-keyword">while</span> [ <span class="hljs-variable">$i</span> -le <span class="hljs-variable">$1</span> ]<br><span class="hljs-keyword">do</span><br><span class="hljs-attribute">SUM</span>=$[<span class="hljs-variable">$SUM</span>+<span class="hljs-variable">$i</span>]<br><span class="hljs-attribute">i</span>=$[<span class="hljs-variable">$i</span>+1]<br>done<br>echo <span class="hljs-string">&quot;执行结果=<span class="hljs-variable">$SUM</span>&quot;</span><br>【退出文件】<br>chmod u+x testWhile.sh<br>./testWhile.sh 10<br></code></pre></td></tr></table></figure><h4 id="read从控制台输入"><a href="#read从控制台输入" class="headerlink" title="read从控制台输入"></a>read从控制台输入</h4><p>read [选项] 参数</p><p>-p  指定读取值时的提示符</p><p>-t  指定读取值时等待的时间，如果没有在指定的时间输入，就不再等待了</p><p><strong>应用实例</strong></p><p>案例：</p><p>读取控制台输入的num值，在10秒内输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim testRead.sh<br>【文件中】<br><span class="hljs-comment">#！/bin/bash</span><br><span class="hljs-built_in">read</span> -t 10 -p <span class="hljs-string">&quot;请输入一个数NUM1=&quot;</span> NUM1<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;你输入的NUM1=<span class="hljs-variable">$NUM1</span>&quot;</span><br>【退出文件】<br><span class="hljs-built_in">chmod</span> u+x testRead.sh<br>./testRead.sh<br></code></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>shell有系统函数，也可以自定义函数</p><h4 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h4><ul><li><p>basename</p><p>功能：返回完整路径最后&#x2F;部分，常用于获取文件名</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">basename /home/<span class="hljs-keyword">aaa</span>/<span class="hljs-keyword">test</span><span class="hljs-number">.</span>txt<br>返回<span class="hljs-keyword">test</span><span class="hljs-number">.</span>txt<br>basename /home/<span class="hljs-keyword">aaa</span>/<span class="hljs-keyword">test</span><span class="hljs-number">.</span>txt .txt<br>返回<span class="hljs-keyword">test</span><br></code></pre></td></tr></table></figure></li><li><p>dirname</p><p>功能：返回完整路径最后&#x2F;前面的部分，常用于返回路径部分</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">dirname <span class="hljs-regexp">/home/</span>aaa/test.txt<br>返回<span class="hljs-regexp">/home/</span>aaa<br></code></pre></td></tr></table></figure></li></ul><h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><p>案例：计算两个参数的和</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim testFun.sh<br>【文件中】<br><span class="hljs-comment">#！/bin/bash</span><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">getSum</span></span>() &#123;<br>SUM=$[<span class="hljs-variable">$n1</span>+<span class="hljs-variable">$n2</span>]<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;和=<span class="hljs-variable">$SUM</span>&quot;</span><br>&#125;<br><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;请输入一个数n1=&quot;</span> n1<br><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;请输入一个数n2=&quot;</span> n2<br>getSum <span class="hljs-variable">$n1</span> <span class="hljs-variable">$n2</span><br>【退出文件】<br><span class="hljs-built_in">chmod</span> u+x testFun.sh<br>./testFun.sh 1 3<br></code></pre></td></tr></table></figure><h2 id="Shell编程综合案例-数据库备份"><a href="#Shell编程综合案例-数据库备份" class="headerlink" title="Shell编程综合案例 数据库备份"></a>Shell编程综合案例 数据库备份</h2><p><strong>需求分析</strong></p><ol><li>每天凌晨2:30备份数据库hspedu到&#x2F;data&#x2F;backup&#x2F;db</li><li>备份开始和备份结束能够给出相应的提示信息</li><li>备份后的文件要求以备份时间为文件名，并打包成.tar.gz的形式，比如:2021-03-12_230201.tar.gz</li><li>在备份的同时，检查是否有10天前备份的数据库文件，如果有就将其删除。</li></ol><p><strong>代码</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs routeros">pwd （显示工作目录）<br>vim mysql_db_backup.sh<br>【文件中】<br><span class="hljs-comment">#！/bin/bash</span><br><span class="hljs-comment"># 备份目录</span><br><span class="hljs-attribute">BACKUP</span>=/data/backup/db<br><span class="hljs-comment"># 当前时间</span><br><span class="hljs-attribute">DATETIME</span>=$(date +%Y-%m-%d_%H%M%S)<br><span class="hljs-comment"># 数据库的地址</span><br><span class="hljs-attribute">HOST</span>=localhost<br><span class="hljs-comment"># 数据库用户名</span><br><span class="hljs-attribute">DB_USER</span>=root<br><span class="hljs-comment"># 数据库密码</span><br><span class="hljs-attribute">DB_PW</span>=root<br><span class="hljs-comment"># 备份的数据库名</span><br><span class="hljs-attribute">DATABASE</span>=hspedu<br><br><span class="hljs-comment"># 创建备份目录，如果不存在，就创建</span><br>[ ! -d <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;BACKUP&#125;</span>/<span class="hljs-variable">$&#123;DATETIME&#125;</span>&quot;</span> ] &amp;&amp; mkdir -p <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;BACKUP&#125;</span>/<span class="hljs-variable">$&#123;DATETIME&#125;</span>&quot;</span><br><span class="hljs-comment"># 备份数据库</span><br>mysqldump -u<span class="hljs-variable">$&#123;DB_USER&#125;</span> -p<span class="hljs-variable">$&#123;DB_PW&#125;</span> <span class="hljs-attribute">--host</span>=<span class="hljs-variable">$&#123;HOST&#125;</span> -q -R --databases <span class="hljs-variable">$&#123;DATABASE&#125;</span> | gzip &gt; <span class="hljs-variable">$&#123;BACKUP&#125;</span>/<span class="hljs-variable">$&#123;DATETIME&#125;</span>/<span class="hljs-variable">$DATETIME</span>.sql.gz<br><br><span class="hljs-comment"># 将文件处理成tar.gz</span><br>cd <span class="hljs-variable">$&#123;BACKUP&#125;</span><br>tar -zcvf <span class="hljs-variable">$DATETIME</span>.tar.gz <span class="hljs-variable">$&#123;DATETIME&#125;</span><br><span class="hljs-comment"># 删除对应的备份目录</span><br>rm -rf <span class="hljs-variable">$&#123;BACKUP&#125;</span>/<span class="hljs-variable">$&#123;DATETIME&#125;</span><br><br><span class="hljs-comment"># 删除10天前的备份文件</span><br><span class="hljs-built_in">find</span> <span class="hljs-variable">$&#123;BACKUP&#125;</span> -atime +10 -name <span class="hljs-string">&quot;*.tar.gz&quot;</span> -exec rm -rf &#123;&#125; \;<br>echo <span class="hljs-string">&quot;备份数据库<span class="hljs-variable">$&#123;DATABASE&#125;</span> 成功~&quot;</span><br>【退出文件】<br>chmod u+x mysql_db_backup.sh<br>./mysql_db_backup.sh <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux-3</title>
    <link href="/2022/03/02/Linux-3/"/>
    <url>/2022/03/02/Linux-3/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux组的介绍"><a href="#Linux组的介绍" class="headerlink" title="Linux组的介绍"></a>Linux组的介绍</h1><p>在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、所在组、其它组的概念。<br>1.所有者<br>2.所在组<br>3.其它组<br>4.改变用户所在的组</p><h3 id="组的创建"><a href="#组的创建" class="headerlink" title="组的创建"></a>组的创建</h3><p>基本指令：<code>groupadd 组名</code></p><figure class="highlight applescript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs applescript">应用实例：<br>创建一个组monster，然后创建一个用户fox，并放入monster组中。<br>groupadd  monster<br>useradd -g monster fox<br><span class="hljs-built_in">id</span> fox<br></code></pre></td></tr></table></figure><h3 id="文件目录所有者"><a href="#文件目录所有者" class="headerlink" title="文件目录所有者"></a>文件目录所有者</h3><p>一般为文件的创建者，谁创建了该文件，谁就是文件的所有者。</p><p>查看文件的所有者、所在组：<code>ls -ahl</code></p><p>修改文件所有者：<code>chown 用户名 文件名</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">应用实例：使用root，创建一个文件apple.txt，然后将其所有者修改成tom<br><span class="hljs-built_in">chown</span> tom apple.txt<br></code></pre></td></tr></table></figure><h3 id="文件目录所在组"><a href="#文件目录所在组" class="headerlink" title="文件目录所在组"></a>文件目录所在组</h3><p>当用户创建了文件之后，文件所在的组就是该用户所在的组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">应用实例：使用fox创建一个文件，看该文件属于哪个组<br><span class="hljs-built_in">pwd</span>（查看当前是否属于fox用户）<br><span class="hljs-built_in">touch</span> xxx（文件名）（创建一个文件）<br><span class="hljs-built_in">ls</span> -ahl（查看文件的所在组）<br></code></pre></td></tr></table></figure><h3 id="修改文件所在组"><a href="#修改文件所在组" class="headerlink" title="修改文件所在组"></a>修改文件所在组</h3><p><code>chgrp 组名 文件名</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">应用实例：root用户创建文件orange.txt，看该文件属于哪个组，然后将文件所在组修改到fruit组。<br>groupadd fruit<br><span class="hljs-built_in">touch</span> orange.txt<br><span class="hljs-built_in">chgrp</span> fruit orange.txt<br></code></pre></td></tr></table></figure><h3 id="其他组"><a href="#其他组" class="headerlink" title="其他组"></a>其他组</h3><p>出文件所有者和所在组的用户外，系统的其他用户都是文件的其他组。</p><h3 id="改变用户所在组"><a href="#改变用户所在组" class="headerlink" title="改变用户所在组"></a>改变用户所在组</h3><p>在添加用户时，可以指定将该用户添加到哪个组中，同样的用root的管理权限也可以改变某个用户所在的组。</p><ol><li><p>usermod -g 新组名 用户名</p></li><li><p>usermod -d 目录名 用户名 （改变该用户登录的初始目录）</p><p>说明：用户需要有进入到新目录的权限。</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">应用实例：<br>将zwj用户从原来所在组修改到wudang组。<br><span class="hljs-built_in">id</span> zwj <br><span class="hljs-built_in">cat</span> /etc/group | grep wudang<br>usermod -g wudang zwj<br></code></pre></td></tr></table></figure><h1 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h1><h3 id="权限基本介绍"><a href="#权限基本介绍" class="headerlink" title="权限基本介绍"></a>权限基本介绍</h3><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184841.png" alt="image-20220225201648459"></p><p>文件及目录权限应用实例：</p><p><code>ls -l</code> 中显示的内容如下：</p><p><code>-rwxrw-r-- 1 root root 1213 Feb 2 09:39 abc</code></p><p>第一个字符代表文件类型：<code>- l d c b</code></p><p>其余三个字符每3个一组（rwx）：读（r）写（w）执行（x）</p><ul><li><p>第一组rwx：文件拥有者的权限是读、写和执行</p></li><li><p>第二组rw-：与文件拥有者同一组的用户的权限是读、写，但不能执行</p></li><li><p>第三组r–：不与文件拥有者同组的其他用户的权限是读，不能写和执行</p></li></ul><p>可用数字表示为：<code>r=4 w=2 x=1</code>，因此rwx&#x3D;4+2+1&#x3D;7</p><p>其他说明：</p><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184844.png" alt="image-20220227132345761"></p><h3 id="rwx权限详解"><a href="#rwx权限详解" class="headerlink" title="rwx权限详解"></a>rwx权限详解</h3><ul><li><p>rwx作用到文件</p><ol><li><p>【r】代表可读：可以读取、查看。</p></li><li><p>【w】代表可写：可以修改，不能删除。</p><p>（删除的前提是对该文件所在的目录有写权限）</p></li><li><p>【x】代表可执行：可以被执行。</p></li></ol></li><li><p>rwx作用到目录</p><ol><li>【r】代表可读：可以被读取，ls查看目录内容。</li><li>【w】代表可写：可以修改，对目录内创建、删除、重命名目录。</li><li>【x】代表可执行：可以进入该目录。</li></ol></li></ul><h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><p><code>chmod</code>可以修改文件或目录的权限。</p><ul><li><p>通过+、-、&#x3D;变更权限</p><p>u：所有者     g：所在组    o：其他人    a：所有人（ugo的总和）</p><p>例：<code>chmod u=rwx,g=rx,o=x 目录/目录名</code></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vim">应用案例：<br><span class="hljs-number">1</span>. 给<span class="hljs-keyword">abc</span>文件的所有者读写执行的权限，给所在组读执行权限，给其他组读执行权限。<br>chmod <span class="hljs-keyword">u</span>=rwx,g=rx,<span class="hljs-keyword">o</span>=rx <span class="hljs-keyword">abc</span><br><span class="hljs-number">2</span>. 给<span class="hljs-keyword">abc</span>文件的所有者除去执行的权限，增加读写的权限<br>chmod <span class="hljs-keyword">u</span>-<span class="hljs-keyword">x</span>,g+<span class="hljs-keyword">w</span> <span class="hljs-keyword">abc</span><br><span class="hljs-number">3</span>. 给<span class="hljs-keyword">abc</span>文件的所有用户添加读的权限<br>chmod <span class="hljs-keyword">a</span>+r <span class="hljs-keyword">abc</span><br></code></pre></td></tr></table></figure></li><li><p>通过数字变更权限</p><p>r&#x3D;4    w&#x3D;2    x&#x3D;1    rwx&#x3D;4+2+1&#x3D;7</p><p>例：<code>chmod u=rwx,g=rx,o=x 目录/目录名</code> &#x3D;&#x3D; <code>chmod 751 文件目录名</code></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">应用案例：<br><span class="hljs-number">1</span>. 将<span class="hljs-regexp">/home/</span>abc.txt文件的权限修改成rwxr-xr-x<br>chmod <span class="hljs-number">755</span> <span class="hljs-regexp">/home/</span>abc.txt<br></code></pre></td></tr></table></figure></li></ul><h3 id="修改文件所有者"><a href="#修改文件所有者" class="headerlink" title="修改文件所有者"></a>修改文件所有者</h3><p><code>chown 新所有者 文件或目录</code>  改变所有者</p><p><code>chown 新所有者:新组 文件或目录</code>  改变所有者和所在组</p><p><code>-R</code> 如果是目录，则使其下所有的子文件或目录递归生效</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">应用案例：<br><span class="hljs-number">1</span>. 将 <span class="hljs-regexp">/home/</span>abc.txt 文件的所有者修改成 tom<br>chown tom <span class="hljs-regexp">/home/</span>abc.txt<br><span class="hljs-number">2</span>. 将 <span class="hljs-regexp">/home/</span>test 目录下所有的文件和目录的所有者都修改成tom<br>chown -R tom <span class="hljs-regexp">/home/</span>test<br></code></pre></td></tr></table></figure><h3 id="修改文件、目录所在组"><a href="#修改文件、目录所在组" class="headerlink" title="修改文件、目录所在组"></a>修改文件、目录所在组</h3><p><code>chgrp 新组 文件或目录</code></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">应用案例：<br><span class="hljs-number">1</span>. 将 <span class="hljs-regexp">/home/</span>abc.txt 文件的所在组改成 shaolin<br>gruopadd shaolin<br>chgrp shaolin <span class="hljs-regexp">/home/</span>abc.txt<br><span class="hljs-number">2</span>. 将 <span class="hljs-regexp">/home/</span>test 目录下的所有文件和目录 的所在组都改成shaolin<br>chgrp -R shaolin <span class="hljs-regexp">/home/</span>test<br></code></pre></td></tr></table></figure><h1 id="crond任务调度"><a href="#crond任务调度" class="headerlink" title="crond任务调度"></a>crond任务调度</h1><p>任务调度：是指系统在某个时间执行的特定的命令或程序</p><p>任务调度分类：系统工作如病毒扫描等某些周而复始的工作，或个别用户工作如数据库的备份等。</p><p><code>crontab</code>   进行定时任务的设置</p><ul><li><p>-e        编辑crontab定时任务</p></li><li><p>-l         查询crontab任务</p></li><li><p>-r         删除当前用户所有的crontab任务</p></li></ul><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p>设置任务调度文件：<code>/etc/crontab</code></p><p>设置个人任务调度，执行 <code>crontab -e</code> 命令</p><p>输入任务到调度文件</p><p><code>*/1 * * * * ls -l /etc/ &gt;/tmp/to.txt</code></p><p>意思是每小时的每分钟执行<code>ls -l /etc/ &gt;/tmp/to.txt</code>命令</p><h3 id="占位符及特殊符号的说明"><a href="#占位符及特殊符号的说明" class="headerlink" title="占位符及特殊符号的说明"></a>占位符及特殊符号的说明</h3><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184851.png" alt="image-20220225203025679"></p><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184853.png" alt="image-20220225203039641"></p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p><code>cronrtab -r</code>：终止任务调度</p><p><code>cronrtab -l</code>：列出当前有哪些任务调度</p><p><code>service crond restart</code>：重启任务调度</p><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184855.png" alt="image-20220225203103951"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">应用案例：<br><span class="hljs-number">1</span>. 每隔<span class="hljs-number">1</span>分钟，就将当前的日期信息追加到<span class="hljs-regexp">/tmp/my</span>date文件中<br>*<span class="hljs-regexp">/1 * * * * date &gt;&gt; /</span>tmp/mydate<br><span class="hljs-number">2</span>. 每隔<span class="hljs-number">1</span>分钟，将当前日期和日历都追加到<span class="hljs-regexp">/home/my</span>cal文件中<br>vim <span class="hljs-regexp">/home/my</span>.sh <br>date &gt;&gt; <span class="hljs-regexp">/home/my</span>cal 和 cal &gt;&gt; <span class="hljs-regexp">/home/my</span>cal（写入内容）<br>chmod u+x <span class="hljs-regexp">/home/my</span>.sh （给my.sh增加执行权限）<br>crontab -e <br>*<span class="hljs-regexp">/1 * * * * /</span>home/my.sh<br><span class="hljs-number">3</span>. 每天凌晨两点将mysql数据库testdb备份到文件中<br>crontab -e<br><span class="hljs-number">0</span> <span class="hljs-number">2</span> * * * mysqldump -uroot -proot testdb &gt;&gt; <span class="hljs-regexp">/home/</span>db.bak<br><br></code></pre></td></tr></table></figure><blockquote><p>说明：</p><p>可以通过写一个脚本，直接执行脚本</p><p><code>vim my.sh</code></p><p>打开文件之后写入：</p><p><code>date &gt;&gt; /home/mycal</code></p><p><code>cal &gt;&gt; /home/mycal</code></p><p>更改权限：</p><p><code>chmod u+x my.sh</code></p><p>执行脚本：<code>./my.sh</code></p></blockquote><h3 id="at定时任务"><a href="#at定时任务" class="headerlink" title="at定时任务"></a>at定时任务</h3><ol><li><p>at是<u>一次性</u>定时计划任务。</p></li><li><p>at的守护进程atd会以后台模式运行，检查作业队列运行。</p></li><li><p>默认情况下，atd守护进程每60秒检查作业队列，有作业时，会检查作业运行时间，如果时间与当前时间匹配，则运行此作业。</p></li><li><p>在使用at命令的时候，一定要保证atd进程的启动</p></li><li><p>查看atd进程是否启动：<code>ps -ef | grep atd</code></p></li><li><p>at 命令格式：</p><p><code>at [选项] [时间]</code></p><p><code>ctrl+D</code> 结束at命令的输入</p></li></ol><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184858.png" alt="image-20220225203643172"></p><h1 id="磁盘分区机制"><a href="#磁盘分区机制" class="headerlink" title="磁盘分区机制"></a>磁盘分区机制</h1><p>原理：</p><ol><li><p>Linux只有一个根目录，一个独立且唯一的文件结构，每个分区都是用来组成整个文件系统的一部分。</p></li><li><p>Linux采用了一种叫“载入”的处理方法，它将一个分区和一个目录联系起来。</p></li></ol><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184900.png" alt="image-20220225204003514"></p><h3 id="Linux分区"><a href="#Linux分区" class="headerlink" title="Linux分区"></a>Linux分区</h3><p>查看所有设备挂载情况：<code>lsblk</code> 或者 <code>lsblk -f</code></p><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184902.png" alt="image-20220225204057400"></p><h3 id="硬盘说明"><a href="#硬盘说明" class="headerlink" title="硬盘说明"></a>硬盘说明</h3><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184919.png" alt="image-20220225204131928"></p><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184923.png" alt="image-20220225204214815"></p><h3 id="增加磁盘案例"><a href="#增加磁盘案例" class="headerlink" title="增加磁盘案例"></a>增加磁盘案例</h3><p>（P59）此处没有进行实操。</p><ol><li>虚拟机添加硬盘</li><li>分区</li><li>格式化</li><li>挂载</li><li>设置可以自动挂载</li></ol><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184926.png" alt="image-20220225204947122"></p><h3 id="查询系统整体磁盘使用情况"><a href="#查询系统整体磁盘使用情况" class="headerlink" title="查询系统整体磁盘使用情况"></a>查询系统整体磁盘使用情况</h3><p><strong>整体磁盘查询</strong></p><p><code>df -h</code></p><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184929.png" alt="image-20220225205228173"></p><hr><p><strong>特定磁盘查询</strong></p><p><code>du -h 目录</code>  查询指定目录的磁盘占用情况，默认为当前目录</p><p>-s                         指定目录占用大小汇总</p><p>-h                         带计量单位</p><p>-a                         含文件</p><p>-c                         列出明细的同时，增加汇总值</p><p>–max-depth&#x3D;1    子目录深度</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-number">1</span>. 查询 /<span class="hljs-keyword">opt</span> 目录的磁盘占用情况，深度为<span class="hljs-number">1</span>：<br>du -h --<span class="hljs-built_in">max</span>-depth=<span class="hljs-number">1</span> /<span class="hljs-keyword">opt</span><br><br><span class="hljs-number">2</span>. 包含文件夹：<br>du -<span class="hljs-keyword">ha</span> --<span class="hljs-built_in">max</span>-depth=<span class="hljs-number">1</span> /<span class="hljs-keyword">opt</span><br><br><span class="hljs-number">3</span>. 列出明细，增加汇总值：<br>du -hac --<span class="hljs-built_in">max</span>-depth=<span class="hljs-number">1</span> /<span class="hljs-keyword">opt</span><br></code></pre></td></tr></table></figure><hr><p><strong>磁盘情况指令</strong></p><ol><li><p>统计 &#x2F;opt 文件夹下文件的个数</p><p><code>ls</code></p><p><code>ls -l /opt</code></p><p><code>ls -l /opt | grep &quot;^-&quot;</code></p><p><code>ls -l /opt | grep &quot;^-&quot; | wc -l</code></p></li><li><p>统计 &#x2F;opt 文件夹下目录的个数</p><p><code>ls -l /opt | grep &quot;^d&quot; | wc -l</code></p></li><li><p>统计 &#x2F;opt 文件夹下文件的个数，包括子文件夹里的</p><p><code>ls -lR /opt | grep &quot;^-&quot; | wc -l</code></p></li><li><p>统计 &#x2F;opt 文件夹下目录的个数，包括子文件夹里的</p><p><code>ls -lR /opt | grep &quot;^d&quot; | wc -l</code></p></li><li><p>以树状显示目录结构</p><p><code>tree 目录</code></p></li></ol><h1 id="进程基本介绍"><a href="#进程基本介绍" class="headerlink" title="进程基本介绍"></a>进程基本介绍</h1><ol><li><p>在Linux中，每一个执行的程序都称为一个<u>进程</u>，每一个进程都分配一个ID号（pid，进程号）</p></li><li><p>每个进程都是以两种方式存在的，<u>前台与后台</u>。</p><p>前台：用户目前屏幕上可以操作的</p><p>后台：实际在操作，但是屏幕上无法看到，通常以后台方式进行</p></li><li><p>一般系统的服务都是以后台进程的方式存在，都会常驻在系统中，直到关机才结束</p></li></ol><h3 id="显示系统执行的进程"><a href="#显示系统执行的进程" class="headerlink" title="显示系统执行的进程"></a>显示系统执行的进程</h3><p>ps指令是用来查看目前系统中，有哪些正在执行，以及他们执行的状况，可以不加任何参数</p><p>ps显示的信息选项：</p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>PID</td><td>进程识别号</td></tr><tr><td>TTY</td><td>终端机号</td></tr><tr><td>TIME</td><td>此进程所消耗的CPU时间</td></tr><tr><td>CMD</td><td>正在执行的命令或进程名</td></tr></tbody></table><p><code>ps -a</code> 显示当前终端的所有进程信息</p><p><code>ps -u</code> 以用户的格式显示进程信息</p><p><code>ps -x</code> 显示后台进程运行的参数</p><h3 id="ps详解"><a href="#ps详解" class="headerlink" title="ps详解"></a>ps详解</h3><h4 id="进程详解信息"><a href="#进程详解信息" class="headerlink" title="进程详解信息"></a>进程详解信息</h4><p>可以使用 <code>ps -aux | more</code>查看进程详细信息</p><p>也可以使用grep进行过滤 <code>ps -aux | grep xxx</code></p><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184941.png" alt="image-20220226123736480"></p><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184944.png" alt="image-20220226123617462"></p><h4 id="全格式详解所有进程"><a href="#全格式详解所有进程" class="headerlink" title="全格式详解所有进程"></a>全格式详解所有进程</h4><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184948.png" alt="image-20220226123844202"></p><p>以全格式显示当前的所有进程：<code>ps -ef | grep xxx</code></p><h3 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h3><p>某个进程执行到一半需要停止时，或是已经消耗了很大的系统资源时，可以考虑关掉该进程</p><p><code>kill [选项] 进程号</code> ：通过进程号杀死进程</p><p><code>killall 进程名称</code> ：通过进程名称杀死进程，也支持通配符<br><code>-9</code> 表示强迫进程立即停止</p><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184950.png" alt="image-20220226124209244"></p><p>案例一：需要踢掉某个非法登录用户</p><img src="https://gitee.com/li-il/pics/raw/master/20220228184953.png" alt="image-20220226124523588" style="zoom:200%;" /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 踢掉某个非法登录用户<br><span class="hljs-built_in">kill</span> 进程号，比如<span class="hljs-built_in">kill</span> 11421<br>说明：因为priv是先导进程，所以杀掉父进程，子进程也会被杀掉<br>2. 终止远程登陆服务sshd，在适当的时候再次重启sshd服务<br><span class="hljs-built_in">kill</span> sshd对应的进程号<br>/bin/systemctl start sshd.service<br>3. 终止多个gedit<br>killall gedit<br>4. 强制杀掉一个终端<br><span class="hljs-built_in">kill</span> -9 bash对应的进程号<br></code></pre></td></tr></table></figure><h3 id="pstree指令"><a href="#pstree指令" class="headerlink" title="pstree指令"></a>pstree指令</h3><p>pstree [选项]：更加直观的查看进程信息</p><p>-p          显示进程的PID</p><p>-u          显示进程的所属用户</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">应用实例：<br><span class="hljs-bullet">1.</span> 以树状的形式显示进程的pid<br>pstree -p<br><span class="hljs-bullet">2.</span> 以树状的形式显示进程的用户<br>pstree -u<br><span class="hljs-bullet">3.</span> 额外小知识 在root用户下，查看所有的用户和密码<br>cat /etc/passwd<br></code></pre></td></tr></table></figure><h1 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h1><ul><li>介绍</li></ul><p>服务：本质就是进程，但是运行在后台，通常会监听某个端口，等待其他程序的请求，比如mysqld，sshd，防火墙等，又称为守护进程。</p><ul><li>service 管理指令</li></ul><ol><li><p>service 服务名【start、stop、restart、reload、status】</p></li><li><p>在centOS7.0后服务大多数使用<code>systemctl</code></p></li><li><p>service指令管理的服务在<code>/etc/init.d</code>查看</p><p><code>ls -l /etc/init.d</code></p></li><li><p>需要使用service指令，查看，关闭，启动network</p><p>（需要在虚拟系统演示，因为网络连接会关闭）</p></li><li><p>原理解释：在系统中，mysql客户端会去找Linux的端口号（3306），然后开启对应的后台进程</p></li></ol><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184959.png" alt="image-20220226125639370"></p><h3 id="查看服务名"><a href="#查看服务名" class="headerlink" title="查看服务名"></a>查看服务名</h3><ul><li>使用<code>setup</code> 就可以看到所有的系统服务</li><li><code>ls -l /etc/init.d</code> 查看service指令管理的服务</li></ul><h3 id="服务的运行级别"><a href="#服务的运行级别" class="headerlink" title="服务的运行级别"></a>服务的运行级别</h3><p><img src="https://gitee.com/li-il/pics/raw/master/20220228185001.png" alt="image-20220226125949280"></p><h3 id="服务管理-1"><a href="#服务管理-1" class="headerlink" title="服务管理"></a>服务管理</h3><ul><li><p>介绍</p><p>chkconfig指令可以给服务的各个运行级别设置自启动或自关闭</p><p>chkconfig指令管理的服务在&#x2F;etc&#x2F;init.d上查看</p></li><li><p>基本语法</p><p> <code>chkconfig --list</code> </p><p><code>chkconfig --list | grep xxx</code></p><p><code>chkconfig --level 5 服务名 on/off</code></p></li><li><p>应用实例</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">对network服务进行各种操作，把network在<span class="hljs-number">3</span>运行级别关闭自启动<br>chkconfig <span class="hljs-comment">--level 3 network off</span><br></code></pre></td></tr></table></figure></li><li><p>chkconfig重新设置服务自启动或者关闭，需要重启reboot生效</p></li></ul><h3 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h3><ul><li><p>systemctl管理指令</p><p><code>systemctl 【start、stop、restart、status】 服务名</code></p><p>systemctl指令管理的服务可以在&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system查看</p></li><li><p>systemctl设置服务的自启动状态</p><p><code>systemctl list-unit-files [| grep 服务名]</code> 查看服务开机启动状态</p><p><code>systemctl enable 服务名</code> 设置服务开机启动</p><p><code>systemctl disable 服务名</code> 关闭服务开机启动</p><p><code>systemctl is-enabled 服务名</code> 查询某个服务是否是自启动的</p></li><li><p>应用案例</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">查看当前防火墙的状况，关闭和重启防火墙<br><span class="hljs-string">systemctl</span> <span class="hljs-string">status</span> <span class="hljs-string">firewalld</span><br><span class="hljs-string">systemctl</span> <span class="hljs-string">stop</span> <span class="hljs-string">firewalld</span><br><span class="hljs-string">systemctl</span> <span class="hljs-string">start</span> <span class="hljs-string">firewalld</span><br>上课演示，查看服务<br><span class="hljs-string">ls</span> -<span class="hljs-string">l</span> /<span class="hljs-string">usr</span>/<span class="hljs-string">lib</span>/<span class="hljs-string">systemd</span>/<span class="hljs-string">system</span> | <span class="hljs-string">grep</span> <span class="hljs-string">fire</span><br><span class="hljs-string">systemctl</span> <span class="hljs-built_in">list-unit-files</span> | <span class="hljs-string">grep</span> <span class="hljs-string">firewalld</span><br><span class="hljs-string">systemctl</span> <span class="hljs-string">is-enabled</span> <span class="hljs-string">firewalld</span><br><span class="hljs-string">systemctl</span> <span class="hljs-string">is-enabled</span> <span class="hljs-string">sshd</span>.<span class="hljs-string">service</span><br></code></pre></td></tr></table></figure></li><li><p>细节讨论</p><p>关闭或重启防火墙后，立即生效。（telent 测试某个端口即可）。</p><p>这种方式是临时生效，重启系统后，回归以前对服务的设置。</p><p>如果希望某服务启动或关闭永久生效，就使用<code>systemctl [enabled/disabled] 服务名</code>。</p></li></ul><h3 id="打开或关闭指定端口"><a href="#打开或关闭指定端口" class="headerlink" title="打开或关闭指定端口"></a>打开或关闭指定端口</h3><ul><li>firewall指令</li></ul><p>​    <code>firewall-cmd --permanent --add-port=端口号/协议</code>     打开端口</p><p>​    <code>    firewall-cmd --permanent --remove-port=端口号/协议</code>    关闭端口</p><p>​    <code>    firewall-cmd --reload</code>    重新载入，才能生效</p><p>​    <code>   firewall-cmd --permanent --query-port=端口号/协议   </code>查询端口是否开放</p><ul><li><p>应用案例</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>. 启用防火墙，测试<span class="hljs-number">111</span>端口是否能telent<br><span class="hljs-attribute">netstat</span> -anp | more 查看对应的协议<br><span class="hljs-attribute">telnet</span> <span class="hljs-number">192.168.200.130</span> <span class="hljs-number">111</span><br><span class="hljs-attribute">2</span>. 开放<span class="hljs-number">111</span>端口<br><span class="hljs-attribute">firewall</span>-cmd --permanent --add-port=<span class="hljs-number">111</span>/tcp<br><span class="hljs-attribute">firewall</span>-cmd --reload<br><span class="hljs-attribute">firewall</span>-cmd --permanent --query-port=<span class="hljs-number">111</span>/tcp<br><span class="hljs-attribute">3</span>. 关闭<span class="hljs-number">111</span>端口<br><span class="hljs-attribute">firewall</span>-cmd --permanent --remove-port=<span class="hljs-number">111</span>/tcp<br></code></pre></td></tr></table></figure></li></ul><h3 id="动态监控进程"><a href="#动态监控进程" class="headerlink" title="动态监控进程"></a>动态监控进程</h3><p>top与ps命令很相似，都是用来显示正在执行的进程，但是top在执行一段时间后，可以更新正在运行的进程。</p><p><code>top【选项】</code></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-d 秒数</td><td>指定top命令每隔几秒更新，默认是3秒</td></tr><tr><td>-i</td><td>使top不显示任何限制或僵死进程</td></tr><tr><td>-p</td><td>指定监控进程ID来仅仅监视某个进程的状态</td></tr></tbody></table><blockquote><p><img src="https://gitee.com/li-il/pics/raw/master/20220228185007.png" alt="image-20220226143535876"></p><p>三个值加起来除以三，如果在0.7以上，就需要注意了，说明系统负载比较大</p><p>在终端输入top，然后观察进程（P78）</p></blockquote><h3 id="动态监控"><a href="#动态监控" class="headerlink" title="动态监控"></a>动态监控</h3><p><strong>交互操作说明</strong></p><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>P</td><td>以CPU使用率排序，默认就是此项</td></tr><tr><td>M</td><td>以内存的使用率排序</td></tr><tr><td>N</td><td>以PID排序</td></tr><tr><td>q</td><td>退出top</td></tr></tbody></table><p><strong>应用案例</strong></p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-number">1.</span> 监视特定用户，例如tom<br><span class="hljs-built_in">top</span>：输入此命令，然后回车，查看执行的进程<br>u：然后输入u，回车，在输入用户名，即可<br><span class="hljs-number">2.</span> 终止指定的进程，例如结束tom登录<br><span class="hljs-built_in">top</span><br>k<br>输入要结束的进程ID号<br><span class="hljs-number">9</span> （输入信号量，强制关闭）<br><span class="hljs-number">3.</span> 指定系统状态更新的时间（每隔<span class="hljs-number">10</span>秒自动更新），默认是<span class="hljs-number">3</span>秒<br><span class="hljs-built_in">top</span> -d <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h3 id="查看系统网络情况netstat"><a href="#查看系统网络情况netstat" class="headerlink" title="查看系统网络情况netstat"></a>查看系统网络情况netstat</h3><p><code>netstat [选项]</code></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-an</td><td>按一定顺序排序输出</td></tr><tr><td>-p</td><td>显示哪个进程正在调用</td></tr></tbody></table><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">应用案例<br>查看服务名为sshd的服务的信息<br>netstat -anp <span class="hljs-string">| grep sshd</span><br></code></pre></td></tr></table></figure><h3 id="检测主机连接命令ping"><a href="#检测主机连接命令ping" class="headerlink" title="检测主机连接命令ping"></a>检测主机连接命令ping</h3><p>是一种网络检测工具，主要是用于检测远程主机是否正常，或者是两部主机间的网线或网卡故障。</p><p><code>ping 对方ip地址</code></p><blockquote><p><img src="https://gitee.com/li-il/pics/raw/master/20220228185011.png" alt="image-20220226144452971"></p><p>ESTABLISHED：已经成功建立连接的</p><p>LISTEN：正在等待建立连接的</p><p>如果是tom用户logout，那么不会立刻断开，而是会有一个timewait的过程</p></blockquote><h1 id="RPM管理"><a href="#RPM管理" class="headerlink" title="RPM管理"></a>RPM管理</h1><p>查看已安装的rpm列表 <code>rpm -qa | grep xxx</code></p><p>举例：查看当前系统是否安装了firefox</p><p><img src="https://gitee.com/li-il/pics/raw/master/20220228185014.png" alt="image-20220227154138600"></p><h3 id="rpm包的其他查询指令"><a href="#rpm包的其他查询指令" class="headerlink" title="rpm包的其他查询指令"></a>rpm包的其他查询指令</h3><p><code>rpm -qa</code>    查询所安装的所有rpm软件包</p><p><code>rpm -qa | more    </code></p><p><code>rpm -qa | grep xxx    </code></p><p><code>rpm -q 软件包名</code>    查询软件包是否安装</p><p><code>rpm -qi 软件包名</code>    查询软件包信息</p><p><code>rpm -ql 软件包名</code>    查询软件包中的文件</p><p><code>rpm -qf 文件全路径名    </code>    查询文件所属的软件包</p><p><code>rpm -qf /etc/passwd</code>    </p><p><code>rpm -qf /root/install.log</code>    </p><p>（例如：软件包名&#x3D;firefox）</p><h3 id="卸载rpm包"><a href="#卸载rpm包" class="headerlink" title="卸载rpm包"></a>卸载rpm包</h3><p><code>rpm -e RPM包名 //erase</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">应用案例<br>删除firefox 软件包<br>rpm -e firefox<br></code></pre></td></tr></table></figure><p><strong>细节讨论</strong></p><p>如果其他软件包依赖于要卸载的软件包，则卸载时会出现错误信息。</p><p><img src="https://gitee.com/li-il/pics/raw/master/20220228185018.png" alt="image-20220227155157344"></p><p>如果要删除foo，可以使用<code>$rpm -e --nodeps foo</code>强制删除，但是一般不推荐，因为依赖于该软件包的程序可能无法运行</p><h3 id="安装rpm包"><a href="#安装rpm包" class="headerlink" title="安装rpm包"></a>安装rpm包</h3><p><code>rpm -ivh RPM包全路径名称</code></p><blockquote><p>i&#x3D;install    安装</p><p>v&#x3D;verbose    提示</p><p>h&#x3D;hash    进度条</p></blockquote><blockquote><p><strong>应用实例</strong><br>卸载和安装firefox</p><p>打开桌面上的驱动，然后进入Packages文件夹</p><p><img src="https://gitee.com/li-il/pics/raw/master/20220228185021.png" alt="image-20220226145128664"></p><p>可以搜索，然后将要安装的软件（如firefox）粘贴到某个文件夹下（如&#x2F;opt）</p><p><img src="https://gitee.com/li-il/pics/raw/master/20220228185024.png" alt="image-20220226145149161"></p></blockquote><h3 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h3><p><strong>介绍</strong></p><p>yum是一个shell前端软件包管理器，基于rpm包管理，能够从指定的服务器自动下载rpm包并安装，可以自动处理依赖性关系，并且一次性安装所有以来的软件包</p><p><strong>yum的基本指令</strong></p><p><code>yum list | grep xx软件列表</code>    查询yum服务器是否有需要安装的软件</p><p><code>yum install xxx    </code>    安装指定的yum包</p><p><strong>应用实例</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">使用yum的方式来安装firefox<br>rpm -r firefox<br>yum list <span class="hljs-string">| grep firefox</span><br>yum install firefox<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux-2</title>
    <link href="/2022/03/02/Linux-2/"/>
    <url>/2022/03/02/Linux-2/</url>
    
    <content type="html"><![CDATA[<h1 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h1><h2 id="帮助信息类"><a href="#帮助信息类" class="headerlink" title="帮助信息类"></a>帮助信息类</h2><p><img src="D:\typora\AllImages\20220228184747.png" alt="image-20220224184447524"></p><p>例如：</p><p><code>man ls</code>：查看目录信息（按住空格键展示更多信息）</p><p><code>ls -al /root</code>：指定root目录，查看下面的所有内容</p><h1 id="文件目录类"><a href="#文件目录类" class="headerlink" title="文件目录类"></a>文件目录类</h1><h2 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h2><p>显示当前工作目录的绝对路径</p><h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p><code>ls [选项] [目录或文件]</code></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-a</td><td>显示当前目录所有的文件和目录，包括隐藏的</td></tr><tr><td>-l</td><td>以列表的方式显示信息</td></tr></tbody></table><h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2><p><code>cd [参数]</code>    切换到指定目录</p><p>参数可以是相对路径或绝对路径</p><p><code>cd ~</code> 或 <code>cd</code> 回到自己的家目录</p><p><code>cd ..</code> 回到当前目录的上一级目录</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p><code>mkdir [选项] 要创建的目录</code>  用于创建目录</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-p</td><td>创建多级目录</td></tr></tbody></table><p><strong>应用案例</strong></p><ol><li>创建一个目录 &#x2F;home&#x2F;dog</li><li>创建多级目录 &#x2F;home&#x2F;animal&#x2F;tiger</li></ol><p><strong>提示</strong>：</p><p>案例2，如果没有animal目录，使用<code>mkdir /home/animal/tiger</code>会报错<code>没有那个文件或目录</code>，应该使用 <strong><code>mkdir -p /home/animal/tiger</code></strong></p><h3 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h3><p><code>rmdir [选项] 要删除的目录</code>  用于删除空目录</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-p</td><td>创建多级目录</td></tr></tbody></table><p><strong>应用案例</strong></p><p>删除一个目录 &#x2F;home&#x2F;dog</p><p><strong>提示</strong>：</p><p>如果要删除<code>/home/animal</code>，但是其下还有tiger文件夹，会删除失败<code>目录非空</code>，需要 <strong><code>rm -rf /home/animal</code></strong></p><p><code>rf</code>代表递归</p><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p><code>touch 文件名称</code>  用于创建空文件</p><p>应用案例：</p><p>在&#x2F;home目录下，创建一个空文件hello.txt</p><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p><strong>基本语法</strong></p><p><code>cp [选项] source dest</code>  用于创建空文件</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-r</td><td>递归复制整个文件夹</td></tr></tbody></table><p><strong>应用案例</strong>：</p><p>1，将 &#x2F;home&#x2F;hello.txt 拷贝到&#x2F;home&#x2F;bbb 目录下</p><p><code>cp hello.txt /home/bbb</code></p><p>在home目录下，只需输入<code>cp hello.txt bbb/</code></p><p>2，递归复制整个文件夹，举例, 比如将 &#x2F;home&#x2F;bbb 整个目录， 拷贝到 &#x2F;opt</p><p><code>cp -r /home/bbb /opt</code></p><p><strong>细节</strong></p><p>强制覆盖不提示的方法：<code>\cp</code></p><p>例如：<code>\cp -r /home/bbb /opt</code></p><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p><strong>基本语法</strong></p><p><code>rm [选项] 要删除的文件或目录</code>  用于移除文件或目录</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-r</td><td>递归删除整个文件夹</td></tr><tr><td>-f</td><td>强制删除不提示</td></tr></tbody></table><p><strong>应用案例</strong>：</p><p>1，将 &#x2F;home&#x2F;hello.txt 删除</p><p><code>rm /home/hello.txt</code></p><p>2，递归删除整个文件夹&#x2F;home&#x2F;bbb，并且不提示</p><p><code>rm -r /home/hello.txt</code>（每删一个文件都会提示一次）</p><p><code>rm -rf /home/hello.txt</code>（删除文件不提示）</p><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p><strong>基本语法</strong></p><p><code>mv oldNameFile newNameFile</code>  重命名</p><p><code>mv /temp/movefile /targetFolder</code>   移动文件</p><p><strong>应用案例</strong>：</p><p>1，将 &#x2F;home&#x2F;cat.txt 文件 重新命名为 pig.txt</p><p><code>mv cat.txt pig.txt</code></p><p>2，将 &#x2F;home&#x2F;pig.txt 文件 移动到 &#x2F;root 目录下</p><p><code>mv pig.txt /root/</code></p><p>移动并且重命名：<code>mv pig.txt /root/cow.txt</code></p><p>3，移动整个目录 , 比如将 &#x2F;opt&#x2F;bbb 移动到 &#x2F;home 下 mv &#x2F;opt&#x2F;bbb &#x2F;home&#x2F;</p><p><code>mv bbb/ /home/</code></p><p>移动bbb文件并且重命名为uuu：<code>mv bbb/ /home/uuu</code></p><blockquote><p>如果文件在同一个目录，就是重命名。</p><p>如果不在，就是移动文件。</p></blockquote><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p><strong>基本语法</strong></p><p><code>cat [选项] 要查看的文件</code>  查看文件内容</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-n</td><td>显示行号</td></tr></tbody></table><p><strong>应用案例</strong></p><p>查看 &#x2F;etc&#x2F;profile 文件内容，并显示行号</p><p><strong>使用细节</strong><br>cat 只能浏览文件，而不能修改文件，为了浏览方便，一般会带上管道命令 <code>| more</code><br><code>cat -n /etc/profile | more</code></p><blockquote><p>管道命令：类似于把前面的结果交给后面处理</p></blockquote><h2 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h2><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p><code>more 要查看的文件</code></p><p>more 指令是一个基于 VI 编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more 指令中内置了若干快捷键用于交互。</p><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184753.png" alt="image-20220227195131619"></p><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p><code>less 要查看的文件</code></p><p>less 指令用来分屏查看文件内容，它的功能与 more 指令类似，但是比 more 指令更加强大，支持各种显示终端。</p><p>less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。</p><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184757.png" alt="image-20220227195230358"></p><h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><p><strong>基本语法</strong></p><p><code>echo [选项] [输出内容]</code>  输出内容到控制台</p><p><strong>应用实例</strong></p><p>在控制台输出hello world</p><p><code>echo &quot;hello,world!&quot;</code></p><h2 id="head"><a href="#head" class="headerlink" title="head"></a>head</h2><p>head 用于显示文件的开头部分内容，默认情况下 head 指令显示文件的前 10 行内容</p><p><strong>基本语法</strong></p><p><code>head 文件</code>  查看文件头 10 行内容</p><p><code>head -n 5 文件</code>  查看文件头 5 行内容，5 可以是任意行数</p><p><strong>应用实例</strong></p><p>查看&#x2F;etc&#x2F;profile 的前面 5 行代码</p><p><code>head -n 5 /etc/profile</code></p><h2 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h2><p>tail 用于输出文件中尾部的内容，默认情况下 tail 指令显示文件的前 10 行内容。</p><p><strong>基本语法</strong></p><p><code>tail 文件</code>  查看文件尾 10 行内容</p><p><code>tail -n 5 文件</code>  查看文件尾 5 行内容，5 可以是任意行数</p><p><code>tail -f 文件</code>  实时追踪该文档的所有更新</p><p><strong>应用实例</strong></p><p>实时监控 mydate.txt , 看看到文件有变化时，是否看到实时的追加 hello,world</p><p><code>tail -f /home/mydate.txt</code></p><blockquote><p>案例会导致当前终端陷入监控状态，需要再打开另一个终端查看效果。</p><p>查看效果举例：打开另一个终端，通过重定向<code>echo &quot;hello&quot; &gt; /home/mydate.txt</code>将”hello”输入到mydate.txt</p><p>暂停监控：<code>ctrl+C</code></p></blockquote><h2 id="输出重定向-gt-和-追加-gt-gt"><a href="#输出重定向-gt-和-追加-gt-gt" class="headerlink" title="输出重定向&gt; 和 追加&gt;&gt;"></a>输出重定向&gt; 和 追加&gt;&gt;</h2><p><strong>基本语法</strong></p><p><code>ls -l &gt;文件</code>  列表的内容写入文件 a.txt 中（覆盖写）</p><p><code>ls -al &gt;&gt;文件</code>  列表的内容追加到文件的末尾</p><p><code>cat 文件 1 &gt; 文件 2</code>  将文件 1 的内容覆盖到文件 2</p><p><code>echo &quot;内容&quot;&gt;&gt; 文件</code>  追加</p><p><strong>应用实例</strong></p><p>1， 将 &#x2F;home 目录下的文件列表 写入到 &#x2F;home&#x2F;info.txt 中, 覆盖写入</p><p><code>ls -l /home &gt; /home/info.txt</code>（如果没有info.txt，则会创建）</p><p>2，将当前日历信息 追加到 &#x2F;home&#x2F;mycal 文件中</p><p><code>cal &gt;&gt; /home/mycal</code></p><p>3，在info.txt里面写入”ok”</p><p><code>echo &quot;ok&quot; &gt; /home/info.txt</code></p><p>4，文件内容覆盖</p><p><code>cat /etc/profile &gt; /home/myprofile</code></p><h2 id="In"><a href="#In" class="headerlink" title="In"></a>In</h2><p>软链接也称为符号链接，类似于 windows 里的快捷方式，主要存放了链接其他文件的路径</p><p><strong>基本语法</strong></p><p><code>ln -s [原文件或目录] [软链接名]</code>  给原文件创建一个软链接</p><p><strong>应用实例</strong></p><p>1， 在&#x2F;home 目录下创建一个软连接 myroot，连接到 &#x2F;root 目录</p><p><code>ln -s /root /home/myroot</code></p><p>可以使用<code>ls -l</code>查看当前的目录</p><p>2，删除软连接 myroot</p><p><code>rm /home/myroot</code></p><blockquote><p>注意：</p><p>删除的时候不能写<code>rm /home/myroot/</code>，不要加最后的斜杠，否则会报错<code>……是一个目录</code></p><p>当我们使用 pwd 指令查看目录时，仍然看到的是软链接所在目录。</p></blockquote><h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><p><strong>基本语法</strong></p><p><code>history</code>  查看已经执行过历史命令</p><p><strong>应用实例</strong></p><p>1， 显示所有的历史命令</p><p><code>history</code></p><p>2，显示最近使用过的 10 个指令</p><p><code>history 10</code></p><p>3， 执行历史编号为 5 的指令</p><p><code>!5</code></p><h2 id="date"><a href="#date" class="headerlink" title="date"></a>date</h2><h3 id="显示时间"><a href="#显示时间" class="headerlink" title="显示时间"></a>显示时间</h3><p><strong>基本语法</strong></p><p><code>date</code>    显示当前时间</p><p><code>date +%Y</code>    显示当前年份</p><p><code>date +%m</code>    显示当前月份</p><p><code>date +%d</code>    显示当前是哪一天</p><p><code>date &quot;+%Y-%m-%d %H:%M:%S&quot;</code>    显示年月日时分秒</p><h3 id="设置时间"><a href="#设置时间" class="headerlink" title="设置时间"></a>设置时间</h3><p><strong>基本语法</strong></p><p><code>date -s 字符串时间</code>    显示当前时间</p><p><strong>应用实例</strong></p><p>设置系统当前时间 ， 比如设置成 2020-11-03 20:02:10<br><code>date -s “2020-11-03 20:02:10”</code></p><h2 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h2><p><strong>基本语法</strong></p><p><code>cal</code>    不加选项，显示本月日历</p><p><strong>应用实例</strong></p><p>案例 1: 显示当前日历     <code>cal</code><br>案例 2: 显示 2020 年日历    <code>cal 2020</code></p><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>find 指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端。</p><p><strong>基本语法</strong></p><p><code>find [搜索范围] [选项]</code>    </p><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184807.png" alt="image-20220227201254477"></p><p><strong>应用实例</strong></p><p>1， 按文件名：根据名称查找&#x2F;home 目录下的 hello.txt 文件</p><p><code>find /home -name hello.txt</code></p><p>2，按拥有者：查找&#x2F;opt 目录下，用户名称为 nobody 的文件</p><p><code>find /opt -user nobody</code></p><p>3，查找整个 linux 系统下大于 200M 的文件（+n 大于 -n 小于 n 等于, 单位有 k,M,G）</p><p><code>find / -size +200M</code></p><h2 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h2><p>locate 指令可以快速定位文件路径。</p><p>locate 指令利用<u>事先建立的系统</u>中所有文件名称及路径的 locate 数据库实现快速定位给定的文件。</p><p>Locate 指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新 locate。</p><p><strong>基本语法</strong></p><p><code>locate</code>   </p><p><strong>应用实例</strong></p><p>1，请使用 locate 指令快速定位 hello.txt 文件所在目录</p><p>2， which 指令，可以查看某个指令在哪个目录下，比如 ls 指令在哪个目录</p><p><code>which ls</code></p><p><strong>说明</strong></p><p>由于 locate 指令基于数据库进行查询，所以第一次运行前，必须使用 updatedb 指令创建 locate 数据库。</p><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>grep 过滤查找 ， 管道符，“|”，表示将前一个命令的处理结果输出传递给后面的命令处理。</p><p><strong>基本语法</strong></p><p><code>grep [选项] 查找内容 源文件</code></p><p> <img src="https://gitee.com/li-il/pics/raw/master/20220228184812.png" alt="image-20220227201621226"> </p><p><strong>应用实例</strong></p><p>1，请在 hello.txt 文件中，查找 “yes” 所在行，并且显示行号</p><p>两种写法：</p><p><code>car /home/hello.txt | grep -n &quot;yes&quot;</code></p><p><code>grep -n &quot;yes&quot; /home/hello.txt</code></p><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><h3 id="gzip-x2F-gunzip"><a href="#gzip-x2F-gunzip" class="headerlink" title="gzip&#x2F;gunzip"></a>gzip&#x2F;gunzip</h3><p><strong>基本语法</strong></p><p><code>gzip 文件</code>   压缩文件，只能将文件压缩为*.gz 文件</p><p><code>gunzip 文件.gz </code>   解压缩</p><p><strong>应用实例</strong></p><p>1，gzip 压缩， 将 &#x2F;home 下的 hello.txt 文件进行压缩</p><p><code>gzip /home/hello.txt</code><br>2， gunzip 压缩， 将 &#x2F;home 下的 hello.txt.gz 文件进行解压缩<br><code>gunzip /home/hello.txt.gz</code></p><h3 id="zip-x2F-unzip"><a href="#zip-x2F-unzip" class="headerlink" title="zip&#x2F;unzip"></a>zip&#x2F;unzip</h3><p><strong>基本语法</strong></p><p><code>zip [选项] XXX.zip</code>   </p><p><code>unzip [选项] XXX.zip </code>   </p><blockquote><p>zip常用选项</p><p><code>-r</code>    递归压缩，即压缩目录</p><p>unzip  常用选项</p><p>-d&lt;目录&gt;   指定解压后文件的存放目录</p></blockquote><p><strong>应用实例</strong></p><p>1，将 &#x2F;home 下的 所有文件&#x2F;文件夹进行压缩成 myhome.zip<br><code>zip -r myhome.zip /home/</code><br>2，将 myhome.zip 解压到 &#x2F;opt&#x2F;tmp 目录下<br><code>mkdir /opt/tmp</code><br><code>unzip -d /opt/tmp /home/myhome.zip</code></p><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p>tar 指令 是打包指令，最后打包后的文件是 .tar.gz 的文件。</p><p><strong>基本语法</strong></p><p><code>tar [选项] XXX.tar.gz 打包的内容  </code>  打包目录，压缩后的文件格式.tar.gz</p><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184816.png" alt="image-20220227202301503"></p><p><strong>应用实例</strong></p><p>1，压缩多个文件，将 &#x2F;home&#x2F;pig.txt 和 &#x2F;home&#x2F;cat.txt 压缩成 pc.tar.gz<br><code>tar -zcvf pc.tar.gz /home/pig.txt /home/cat.txt</code><br>2，将&#x2F;home 的文件夹 压缩成 myhome.tar.gz<br><code>tar -zcvf myhome.tar.gz /home/</code><br>3，将 pc.tar.gz 解压到当前目录<br><code>tar -zxvf pc.tar.gz</code><br>4，将 myhome.tar.gz 解压到 &#x2F;opt&#x2F;tmp2目录下<br><code>mkdir /opt/tmp2</code></p><p><code>tar -zxvf /home/myhome.tar.gz -C /opt/tmp2</code></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux-1</title>
    <link href="/2022/03/01/Linux-1/"/>
    <url>/2022/03/01/Linux-1/</url>
    
    <content type="html"><![CDATA[<h1 id="简介和环境配置"><a href="#简介和环境配置" class="headerlink" title="简介和环境配置"></a>简介和环境配置</h1><h2 id="下载VMWare"><a href="#下载VMWare" class="headerlink" title="下载VMWare"></a>下载VMWare</h2><p>详情参见老师的文档。</p><blockquote><p>补充：</p><p>Linux一共有三个分区，东西都放在根分区</p><p>交换分区：可以临时作为内存的补充，但是速度没有真实内存快。</p><p>boot：1G</p><p>swap：2G</p><p>\</p></blockquote><h2 id="下载CentOS"><a href="#下载CentOS" class="headerlink" title="下载CentOS"></a>下载CentOS</h2><p>详情请见老师的文档。</p><p>CentOS细节介绍</p><blockquote><p><strong>软件选择：</strong><img src="https://gitee.com/li-il/pics/raw/master/20220228184527.png" alt="image-20220223174716248">软件选择之后会检查安装源，需要等待一会儿。</p><p><strong>配置分区：</strong></p><p>选择【我要配置分区】，点击【完成】，后弹出界面。<img src="https://gitee.com/li-il/pics/raw/master/20220228184529.png" alt="image-20220223175032299"></p><p>接下来配置<img src="https://gitee.com/li-il/pics/raw/master/20220228184531.png" alt="image-20220223175441323">然后点击【接受更改】。</p><p><strong>KDUMP：</strong></p><p>是一种内核崩溃转储机制，再系统崩溃的时候用于捕获系统信息。</p><p>如果是实际的生产环境中，可以开启KDUMP。</p><p><strong>设置网络：</strong></p><p>打开即可。</p><p><strong>提醒</strong>：</p><p>实际生活中密码一定要复杂一点。可以使用随机密码生成的。</p><p>输入tar vm之后输入tab，可以自动补全</p></blockquote><h2 id="网络连接的三种方式"><a href="#网络连接的三种方式" class="headerlink" title="网络连接的三种方式"></a>网络连接的三种方式</h2><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184533.png" alt="image-20220223174232519"></p><h2 id="虚拟机的克隆"><a href="#虚拟机的克隆" class="headerlink" title="虚拟机的克隆"></a>虚拟机的克隆</h2><p>如果已经安装了一台虚拟机，就没必要重新安装，直接克隆即可。</p><ol><li><p>直接拷贝一份已经安装好的虚拟机文件。</p><p>在文件夹里面复制粘贴。然后再VM里面选择【打开】。<img src="https://gitee.com/li-il/pics/raw/master/20220228184539.png" alt="image-20220223182419425"></p></li><li><p>使用vm的安装操作</p><p>注意：<strong>克隆时需要先关闭linux系统</strong><img src="https://gitee.com/li-il/pics/raw/master/20220228184541.png" alt="image-20220223182150269"></p></li></ol><h2 id="虚拟机快照"><a href="#虚拟机快照" class="headerlink" title="虚拟机快照"></a>虚拟机快照</h2><p>如果在使用虚拟机的时候，想回到原来的某一个正常的状态（担心某些误操作造成系统异常），需要快照管理。</p><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184633.png" alt="image-20220223182746020"></p><p>返回某快照：在【快照管理】界面，选择需要回到的快照，点击【转到】。</p><h2 id="虚拟机的迁移和删除"><a href="#虚拟机的迁移和删除" class="headerlink" title="虚拟机的迁移和删除"></a>虚拟机的迁移和删除</h2><p>虚拟机的迁移：其实就是文件夹整体的剪切。</p><p>虚拟机的删除：VMWare右键选择【移除】，然后在文件夹中删除整个文件夹。</p><h2 id="安装VMware-Tools"><a href="#安装VMware-Tools" class="headerlink" title="安装VMware Tools"></a>安装VMware Tools</h2><p><strong>场景：</strong>如果想在windows主机和linux虚拟机上都操作同一个文件夹，需要安装VMTools。</p><p><strong>提示：</strong>需要用rooot用户来操作。</p><p><strong>技巧：</strong>VMware Tools安装是灰色的，需要在虚拟机开机之后，没有完全开机之前点击。</p><ol><li>进入CentOS桌面，然后弹出桌面上的驱动。</li><li>点击Vmware菜单【虚拟机】，点击【安装VMTools】，然后桌面上会出现一个光盘名为【VMTools】。</li><li>打开光盘会出现一个文件夹，将文件夹【VMwareTools-10.3.22-15902021.tar.gz】拷贝到【其他位置】【计算机】的&#x2F;opt文件夹下。</li><li>打开终端，进入opt文件夹，使用解压命令<code>tar</code>得到一个安装文件<img src="C:\Users\LXR\AppData\Roaming\Typora\typora-user-images\image-20220223200001696.png" alt="image-20220223200001696"></li><li><code>cd vmware-tools-distrib/</code>进入vm解压后的文件夹下，执行<code>./vmware-install.pl</code>，然后一路回车即可。</li><li>注意：安装的时候需要有gcc，可以通过<code>gcc -v</code>查看自己的gcc版本。</li></ol><p><strong>设置共享文件夹：</strong></p><ol><li><p>设置一个共享文件夹，比如<code>F:\WorkSpace\linux\myshare</code>在文件夹下建立一个<code>a.txt</code></p></li><li><p>打开设置，<img src="https://gitee.com/li-il/pics/raw/master/20220228184639.png" alt="image-20220223200736307"></p><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184641.png" alt="image-20220223200911235"></p><p>在【主机路径】【浏览】下选择刚刚的共享文件夹，然后【下一步】，默认【启用此共享】即可。</p></li><li><p>在<code>计算机/mnt/hgfs</code>下，可以查看共享文件夹。</p></li></ol><p>但是在实际开发中，文件的上传下载是通过远程方式完成的。（经典白学预警 ）</p><h2 id="linux目录结构"><a href="#linux目录结构" class="headerlink" title="linux目录结构"></a>linux目录结构</h2><h3 id="一切皆文件"><a href="#一切皆文件" class="headerlink" title="一切皆文件"></a>一切皆文件</h3><ol><li><p>在linux中，一切皆文件，并把硬件映射成文件形式，且目录无法修改。</p></li><li><p>linux的文件系统是采用<u>级层式的树状目录结构</u>，在此结构中的最上层是根目录<code>/</code>，然后在此目录下再创建其他的目录。</p></li></ol><h3 id="具体的目录结构"><a href="#具体的目录结构" class="headerlink" title="具体的目录结构"></a>具体的目录结构</h3><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184644.png" alt="image-20220223214801594"><img src="https://gitee.com/li-il/pics/raw/master/20220228184647.png" alt="image-20220223214951427"></p><p><img src="C:\Users\LXR\AppData\Roaming\Typora\typora-user-images\image-20220223215020655.png" alt="image-20220223215020655"></p><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184648.png" alt="image-20220223214827389"></p><h3 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h3><p>情景：在公司中开发时，就有以下特点</p><ol><li>linux 服务器是开发小组共享</li><li>正式上线的项目是运行在公网</li><li>因此程序员需要远程登录到 Linux 进行项目管理或者开发</li><li>画出简单的网络拓扑示意图(帮助理解)</li></ol><h4 id="远程登陆"><a href="#远程登陆" class="headerlink" title="远程登陆"></a>远程登陆</h4><ol><li><p>下载XShell</p></li><li><p>测试</p></li></ol><p>在Linux系统下打开终端，查看ip</p><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184651.png" alt="image-20220223215708994"></p><p>然后在Windows系统下打开终端，尝试连接</p><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184652.png" alt="image-20220223215741625"></p><p>打开XShell，【新建】，名称可以随便写但是主机必须正确。<img src="https://gitee.com/li-il/pics/raw/master/20220228184701.png" alt="image-20220223215824277"></p><p>就可以连接到Linux系统了<img src="https://gitee.com/li-il/pics/raw/master/20220228184655.png" alt="image-20220223215953859"></p><h4 id="远程传输"><a href="#远程传输" class="headerlink" title="远程传输"></a>远程传输</h4><p>打开Xftp，点击【新建】，<u>注意端口号也是22</u></p><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184707.png" alt="image-20220223220130019"></p><blockquote><p>乱码解决：左上角文件 - 当前会话属性 - 左上角 常规，点击旁边的“选项”，将“编码”改为UTF-8</p></blockquote><p> <img src="https://gitee.com/li-il/pics/raw/master/20220228184710.png" alt="image-20220223220410675"></p><blockquote><p>windows和linux之间的文件传输是双向的。</p><p>点击【传输】即可。</p></blockquote><h1 id="VI和VIM"><a href="#VI和VIM" class="headerlink" title="VI和VIM"></a>VI和VIM</h1><ol><li>Linux 系统会内置 vi 文本编辑器</li><li>Vim 具有程序编辑的能力，可以看做是 Vi 的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计。<br>代码补完、编译及错误跳转等方便编程的功能<h2 id="VI和VIM的三种常用模式"><a href="#VI和VIM的三种常用模式" class="headerlink" title="VI和VIM的三种常用模式"></a>VI和VIM的三种常用模式</h2></li></ol><p><strong>正常模式</strong><br>VM打开直接进入默认模式，可以使用『上下左右』按键来移动光标，『删除字符』或『删除整行』来处理档案内容， 『复制、粘贴』来处理文件数据。</p><p><strong>插入模式</strong></p><p>按下 i, I, o, O, a, A, r, R 等任何一个字母之后才会进入编辑模式, 一般来说按 i 即可</p><p><strong>命令行模式</strong></p><p>先输入esc，在输入<code>:</code>，可以完成一系列命令操作。</p><h2 id="VI和VIM的基本使用"><a href="#VI和VIM的基本使用" class="headerlink" title="VI和VIM的基本使用"></a>VI和VIM的基本使用</h2><p>使用VIM开发Helloworld.java程序</p><p>在控制台输入<code>vim Hello.java</code>，表示开启一个vim编辑器。</p><p>然后写入java程序后，按住<code>esc</code>，输入<code>:wq</code>表示写入并退出， <code>:q!</code>强制退出不保存。</p><h2 id="各种模式之间的相互切换"><a href="#各种模式之间的相互切换" class="headerlink" title="各种模式之间的相互切换"></a>各种模式之间的相互切换</h2><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184714.png" alt="image-20220223223707481"></p><h3 id="快捷键使用练习"><a href="#快捷键使用练习" class="headerlink" title="快捷键使用练习"></a>快捷键使用练习</h3><ol><li><p>拷贝当前行<code>yy</code> , 拷贝当前行向下的 5 行<code>5yy</code>，并粘贴（输入 p）。</p></li><li><p>删除当前行<code>dd</code>, 删除当前行向下的 5 行 <code>5dd</code></p></li><li><p>在文件中查找某个单词 [命令行下<code> /关键字</code>， 回车 查找 ,输入<code>n</code> 就是查找下一个 ]</p></li></ol><ol start="4"><li>设置文件的行号，取消文件的行号<br> 命令行下 <code>:set nu</code> 和<code>:set nonu</code></li></ol><ol start="5"><li><p>编辑 &#x2F;etc&#x2F;profile 文件，在一般模式下, 使用快捷键到该文档的最末行<code>G</code>和最首行<code>gg</code></p></li><li><p>在一个文件中输入 “hello” ,在一般模式下, 然后又撤销这个动作<code>u</code></p></li><li><p>编辑&#x2F;etc&#x2F;profile 文件，在一般模式下,并将光标移动到 , 输入<code> 20</code>,再输入<code> shift+g</code></p></li><li><blockquote><p>yy：在正常模式下输入，表示拷贝，但是如果是输入模式下，就是输入yy</p><p>输入yy p，表示拷贝</p></blockquote></li></ol><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184717.png" alt="image-20220224120333362"></p><h2 id="登陆注销"><a href="#登陆注销" class="headerlink" title="登陆注销"></a>登陆注销</h2><p><strong>介绍：</strong></p><p>登录时尽量少用root账号登录，因为他是系统管理员，最大的权限，避免操作失误，可以利用普通用户登录，登录后再用  <code>su - 用户名</code>  命令切换成系统管理员身份</p><p>在提示符下输入  <code>logout </code>  可注销用户</p><p><strong>注意</strong>：</p><p>logout注销指令在运行级别3下有效，在图形级别下无效。</p><h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><p>Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统</p><p>由一个root用户可以创建多个用户（例如tom）。</p><h2 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h2><p><strong>基本语法</strong></p><p><code>useradd 用户名</code></p><p><strong>应用案例</strong></p><p>添加一个用户milan</p><blockquote><ol><li><p>当创建米兰用户成功的时候，自动创建该用户的家目录<code>/home/milan</code>，并且在登陆的时候会默认进入该用户的家目录下。</p></li><li><p>也可以通过 <code>useradd -d 指定目录 新的用户名</code>来给新创建的用户指定家目录</p></li></ol><blockquote><p>例如  <code>useradd -d /home/kkk king</code>意为：创建一个用户king，用户的家目录为kkk。</p></blockquote></blockquote><h2 id="指定或修改密码"><a href="#指定或修改密码" class="headerlink" title="指定或修改密码"></a>指定或修改密码</h2><p><strong>基本语法</strong></p><p><code>passwd 用户名</code></p><p><strong>应用案例</strong></p><p>给米兰指定密码</p><blockquote><p>补充：</p><p><code>pwd</code>：显示当前所在目录</p><p><code>id 用户名</code>：查看该用户的信息。</p></blockquote><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><p><strong>基本语法</strong></p><p><code>userdel 用户名</code></p><p>&#96;&#96;userdel -r 用户名&#96;</p><p><strong>应用案例</strong></p><p>删除用户milan，但是保留家目录 <code>userdel milan</code></p><p>删除用户milan以及用户主目录 <code>userdel -r milan</code></p><blockquote><p>需要切换root用户，自己不能删除自己</p><p>一般情况下，建议保留用户主目录</p></blockquote><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><p>在Linux中，如果当前用户的权限不够，可以通过<code>su - 用户名</code>指令，切换到高权限用户，比如root</p><p><strong>基本语法</strong></p><p><code>su - 用户名</code></p><p><strong>应用案例</strong></p><p>创建一个用户jack，指定密码，然后切换到jack</p><blockquote><ol><li>从权限高的用户切换到权限低的用户，不需要输入密码，反之需要</li><li>当需要切换到原来的用户时候，需要使用<code>exit</code>或者<code>logout</code>指令</li><li>查看当前<u>登录</u>用户<code>whoami</code>或<code>who am i</code></li></ol></blockquote><h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><p>系统可以对有共性（权限）的多个用户进行统一的管理</p><p><strong>应用案例</strong></p><p>添加组：<code>groupadd wudang</code></p><p>删除组：<code>groupdel wudang</code></p><p>创建用户的时候加上组：<code>useradd -g wudang zwj</code></p><p>修改组：<code>usermod -g mojiao zwj</code></p><blockquote><p>如果创建用户的时候没有指定组，就会默认创建一个和用户名相同的组并且把用户放进去</p></blockquote><blockquote><p>补充：</p><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184722.png" alt="image-20220224123103176"></p></blockquote><h1 id="Linux实操篇-实用指令"><a href="#Linux实操篇-实用指令" class="headerlink" title="Linux实操篇 实用指令"></a>Linux实操篇 实用指令</h1><h2 id="指定运行级别"><a href="#指定运行级别" class="headerlink" title="指定运行级别"></a>指定运行级别</h2><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184725.png" alt="image-20220224123648038"></p><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184727.png" alt="image-20220224124500877"></p><p>查看当前运行级别：<code>systemctl get-default</code></p><p>设置当前运行级别为3：<code>systemctl set-default multi-user.target</code></p><p>如果改变之后再重启，就会进入运行级别为3的界面。</p><h3 id="Linux找回root用户的密码"><a href="#Linux找回root用户的密码" class="headerlink" title="Linux找回root用户的密码"></a>Linux找回root用户的密码</h3><p><strong>方法：</strong></p><ol><li>首先，启动系统，进入开机界面，在界面中按“e”进入编辑界面。如图<img src="https://gitee.com/li-il/pics/raw/master/20220228184736.png" alt="image-20220224125015927"></li><li>进入编辑界面，使用键盘上的上下键把光标往下移动，找到以““Linux16”开头内容所在的行数”，在行的最后面输入：init&#x3D;&#x2F;bin&#x2F;sh。如图<img src="https://gitee.com/li-il/pics/raw/master/20220228184737.png" alt="image-20220224125032894"></li><li>接着，输入完成后，直接按快捷键：<code>Ctrl+x</code> 进入单用户模式。</li><li>接着，在光标闪烁的位置中输入：<code>mount -o remount,rw /</code>（注意：各个单词间有空格），完成后按键盘的回车键（Enter）。</li><li>在新的一行最后面输入：passwd， 完成后按键盘的回车键（Enter）。输入密码，然后再次确认密码即可(韩顺平提示: 密码长度最好8位以上,但不是必须的), 密码修改成功后，会显示passwd…..的样式，说明密码修改成功<img src="https://gitee.com/li-il/pics/raw/master/20220228184742.png" alt="image-20220224131459675"></li><li>接着，在鼠标闪烁的位置中（最后一行中）输入：touch &#x2F;.autorelabel（注意：touch与 &#x2F;后面有一个空格），完成后按键盘的回车键（Enter）</li><li>继续在光标闪烁的位置中，输入：exec &#x2F;sbin&#x2F;init（注意：exec与 &#x2F;后面有一个空格），完成后按键盘的回车键（Enter）,等待系统自动修改密码(韩顺平提示：这个过程时间可能有点长，耐心等待)，完成后，系统会自动重启, 新的密码生效了<img src="https://gitee.com/li-il/pics/raw/master/20220228184744.png" alt="image-20220224131533785"></li></ol><h1 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h1><h2 id="帮助信息类"><a href="#帮助信息类" class="headerlink" title="帮助信息类"></a>帮助信息类</h2><p><img src="https://gitee.com/li-il/pics/raw/master/20220228184747.png" alt="image-20220224184447524"></p><p>例如：</p><p><code>man ls</code>：查看目录信息（按住空格键展示更多信息）</p><p><code>ls -al /root</code>：指定root目录，查看下面的所有内容</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/02/08/hello-world/"/>
    <url>/2022/02/08/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
      <category>PlayStation</category>
      
      <category>Games</category>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
